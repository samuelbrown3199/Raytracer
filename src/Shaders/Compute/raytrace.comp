#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout(rgba16f, set = 0, binding = 0) uniform image2D image;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct RayHit
{
    vec3 point;
    vec3 normal;
    vec3 colour;
    float t;
    bool frontFace;
};

vec3 PointAtT(float t, Ray ray)
{
	return ray.origin + t * ray.direction;
}

struct Interval
{
    float min;
    float max;
};

bool IntervalSurrounds(Interval interval, float value)
{
    return value >= interval.min && value <= interval.max;
}

struct Sphere
{
    vec3 center;
    float radius;
    vec3 colour;
};

layout(push_constant) uniform constants
{	
    vec3 pixel00Location;
    int raysPerPixel;

    vec3 pixelDeltaU;
    int maxBounces;

    vec3 pixelDeltaV;
    vec3 cameraPosition;
} PushConstants;

bool IntersectSphere(Ray ray, Sphere sphere, Interval t, out RayHit rec)
{
	vec3 oc = sphere.center - ray.origin;
	float a = length(ray.direction)*length(ray.direction);
	float h = dot(ray.direction, oc);
	float c = (length(oc)*length(oc)) - sphere.radius * sphere.radius;
	float discriminant = h * h - a * c;
	if (discriminant < 0)
		return false;

	float sqrtDiscriminant = sqrt(discriminant);
	float root = (h - sqrtDiscriminant) / a;
	if (!IntervalSurrounds(t, root))
	{
		root = (h + sqrtDiscriminant) / a;
		if (!IntervalSurrounds(t, root))
			return false;
	}

	rec.t = root;
	rec.point = PointAtT(rec.t, ray);
	vec3 outwardNormal = (rec.point - sphere.center) / sphere.radius;
    rec.normal = outwardNormal;
    rec.colour = sphere.colour;

	return true;
}

vec3 Raytrace(Ray ray)
{
    Sphere testSphere;
    testSphere.center = vec3(0,0,-5);
    testSphere.radius = 1.0;
    testSphere.colour = vec3(1,0,0);

    Sphere groundSphere;
    groundSphere.center = vec3(0,-1001,-5);
    groundSphere.radius = 1000.0;
    groundSphere.colour = vec3(0.5,0.5,0.5);

    Sphere spheres[2] = Sphere[2](testSphere, groundSphere);

    Interval t;
    t.min = 0.001;
    t.max = 100000;

    float closestSoFar = t.max;
    RayHit rec;

    bool hitObject = false;
    for(int i = 0; i < 2; i++)
    {
        Interval newInterval;
        newInterval.min = t.min;
        newInterval.max = closestSoFar;
        if(IntersectSphere(ray, spheres[i], newInterval, rec))
        {
            closestSoFar = rec.t;
            hitObject = true;
        }
    }

    if(hitObject)
    {
        return rec.colour;
    }
    return vec3(0.0);
}

void main() 
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(image);
    if(texelCoord.x < size.x && texelCoord.y < size.y)
    {
        vec4 colour = vec4(0,0,0,1);
        for(int i = 0; i < PushConstants.raysPerPixel; i++)
        {
			vec3 pixelLocation = PushConstants.pixel00Location + (texelCoord.x * PushConstants.pixelDeltaU) + (texelCoord.y * PushConstants.pixelDeltaV);
			vec3 rayDirection = pixelLocation - PushConstants.cameraPosition;

			Ray ray;
            ray.origin = PushConstants.cameraPosition;
            ray.direction = normalize(rayDirection);

            colour.rgb += Raytrace(ray);
        }
        colour.rgb /= float(PushConstants.raysPerPixel);

        imageStore(image, texelCoord, colour);
    }   
}