#version 450

#extension GL_GOOGLE_include_directive : require

#include "Random.glsl"

layout (local_size_x = 16, local_size_y = 16) in;
layout(rgba16f, set = 0, binding = 0) uniform image2D image;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct Material
{
    vec3 colour;
    float smoothness;
};

struct RayHit
{
    vec3 point;
    vec3 normal;
    Material mat;
    float t;
    bool frontFace;
};

vec3 PointAtT(float t, Ray ray)
{
	return ray.origin + t * ray.direction;
}

struct Interval
{
    float min;
    float max;
};

bool IntervalSurrounds(Interval interval, float value)
{
    return value >= interval.min && value <= interval.max;
}

struct Sphere
{
    vec3 center;
    float radius;
    vec3 colour;
};

layout(set=1, binding=0) readonly buffer SphereBuffer
{
	Sphere spheres[];
};

layout(push_constant) uniform constants
{	
    vec3 pixel00Location;
    int raysPerPixel;

    vec3 pixelDeltaU;
    int maxBounces;

    vec3 pixelDeltaV;
    float defocusAngle;

    vec3 cameraPosition;
    int sphereCount;

    vec3 defocusU;
    vec3 defocusV;

} PushConstants;

bool IntersectSphere(Ray ray, Sphere sphere, Interval t, out RayHit rec)
{
	vec3 oc = sphere.center - ray.origin;
	float a = length(ray.direction)*length(ray.direction);
	float h = dot(ray.direction, oc);
	float c = (length(oc)*length(oc)) - sphere.radius * sphere.radius;
	float discriminant = h * h - a * c;
	if (discriminant < 0)
		return false;

	float sqrtDiscriminant = sqrt(discriminant);
	float root = (h - sqrtDiscriminant) / a;
	if (!IntervalSurrounds(t, root))
	{
		root = (h + sqrtDiscriminant) / a;
		if (!IntervalSurrounds(t, root))
			return false;
	}

	rec.t = root;
	rec.point = PointAtT(rec.t, ray);
	vec3 outwardNormal = (rec.point - sphere.center) / sphere.radius;
    rec.normal = outwardNormal;
    rec.mat.colour = sphere.colour;

	return true;
}

float LinearToGamma(float linearComponent)
{
    if(linearComponent > 0)
		return sqrt(linearComponent);

    return 0;
}

vec3 GetEnvironmentColour(Ray ray)
{
    vec3 unitDirection = normalize(ray.direction);
    float t = 0.5 * (unitDirection.y + 1.0);
    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
}

vec3 Raytrace(Ray ray, inout RayHit rec)
{
    Interval t;
    t.min = 0.001;
    t.max = 100000;

    float closestSoFar = t.max;

    bool hitObject = false;
    for(int i = 0; i < PushConstants.sphereCount; i++)
    {
        Interval newInterval;
        newInterval.min = t.min;
        newInterval.max = closestSoFar;
        if(IntersectSphere(ray, spheres[i], newInterval, rec))
        {
            closestSoFar = rec.t;
            hitObject = true;
        }
    }

    vec3 colour = vec3(0.0,0.0,0.0);
    if(hitObject)
        colour = rec.mat.colour;
    else
        colour = GetEnvironmentColour(ray);

    colour[0] = LinearToGamma(colour[0]);
    colour[1] = LinearToGamma(colour[1]);
    colour[2] = LinearToGamma(colour[2]);

    return colour;
}

vec3 DefocusDiskSample(uint seed)
{
	vec3 p = RandomInUnitDisk(seed);
	return PushConstants.cameraPosition + p.x * PushConstants.defocusU + p.y * PushConstants.defocusV;
}

Ray GetRay(ivec2 pixelCoord, uint seed)
{
    Ray ray;

    vec3 offset = SampleSquare(seed);
	vec3 pixel_sample = PushConstants.pixel00Location + ((pixelCoord.x + offset.x) * PushConstants.pixelDeltaU) + ((pixelCoord.y + offset.y) * PushConstants.pixelDeltaV);

	vec3 ray_origin = (PushConstants.defocusAngle <= 0) ? PushConstants.cameraPosition : DefocusDiskSample(seed);
	vec3 ray_direction = pixel_sample - ray_origin;

    ray.origin = ray_origin;
    ray.direction = normalize(ray_direction);

    return ray;
}

void main() 
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    ivec2 size = imageSize(image);

    if (texelCoord.x < size.x && texelCoord.y < size.y)
    {
        vec4 colour = vec4(0, 0, 0, 1);
        uint seed = SeedFromCoords(texelCoord.x + localCoord.x, texelCoord.y +  localCoord.y);

        for (int i = 0; i < PushConstants.raysPerPixel; i++)
        {
            float junk = RandomSeed(seed);

            Ray ray = GetRay(texelCoord, seed);
            RayHit rec;

            colour.rgb += Raytrace(ray, rec);
        }

        colour.rgb /= float(PushConstants.raysPerPixel);

        imageStore(image, texelCoord, colour);
    }   
}