#version 450

#extension GL_GOOGLE_include_directive : require

#include "Random.glsl"

layout (local_size_x = 32, local_size_y = 32) in;
layout(rgba32f, set = 0, binding = 0) uniform image2D outputImage;
layout(rgba32f, set = 0, binding = 1) uniform image2D accumulationImage;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct Material
{
    vec3 colour;
    float smoothness;
    float emission;
};

struct RayHit
{
    vec3 point;
    vec3 normal;
    int matIndex;
    float t;
    bool frontFace;
    bool hitObject;
};

vec3 PointAtT(float t, Ray ray)
{
	return ray.origin + t * ray.direction;
}

struct Interval
{
    float min;
    float max;
};

bool IntervalSurrounds(Interval interval, float value)
{
    return value >= interval.min && value <= interval.max;
}

struct Sphere
{
    vec3 center;
    float radius;
    int materialIndex;
};

layout(set=1, binding=0) readonly buffer SphereBuffer
{
	Sphere spheres[];
};

layout(set=1, binding=1) readonly buffer MaterialBuffer
{
    Material materials[];
};

layout(push_constant) uniform constants
{	
    vec3 pixel00Location;
    int raysPerPixel;

    vec3 pixelDeltaU;
    int maxBounces;

    vec3 pixelDeltaV;
    float defocusAngle;

    vec3 cameraPosition;
    int sphereCount;

    vec3 defocusU;
    int padding2;

    vec3 defocusV;
    int frame;

    vec3 sunDir;
    float sunStrength;

    vec3 sunColour;

} PushConstants;

bool IntersectSphere(Ray ray, Sphere sphere, Interval t, out RayHit rec)
{
	vec3 oc = sphere.center - ray.origin;
	float a = length(ray.direction)*length(ray.direction);
	float h = dot(ray.direction, oc);
	float c = (length(oc)*length(oc)) - sphere.radius * sphere.radius;
	float discriminant = h * h - a * c;
	if (discriminant < 0)
		return false;

	float sqrtDiscriminant = sqrt(discriminant);
	float root = (h - sqrtDiscriminant) / a;
	if (!IntervalSurrounds(t, root))
	{
		root = (h + sqrtDiscriminant) / a;
		if (!IntervalSurrounds(t, root))
			return false;
	}

	rec.t = root;
	rec.point = PointAtT(rec.t, ray);
	vec3 outwardNormal = (rec.point - sphere.center) / sphere.radius;
    rec.normal = outwardNormal;
    rec.matIndex = sphere.materialIndex;

	return true;
}

bool NearZero(vec3 v)
{
    const float s = 1e-8;
    return (abs(v.x) < s) && (abs(v.y) < s) && (abs(v.z) < s);
}

bool AnyHit(Ray r, float tMin, float tMax)
{
    Interval t; t.min = tMin; t.max = tMax;
    RayHit rec;
    for (int i = 0; i < PushConstants.sphereCount; i++)
    {
        if (IntersectSphere(r, spheres[i], t, rec))
            return true;
    }
    return false;
}

bool MaterialScatter(Ray rayIn, RayHit rec, out vec3 attenuation, out Ray scattered, uint seed)
{
    float scatterOrReflect = RandomFloatInRange(0, 1, seed);
    Material targetMat = materials[rec.matIndex];

    if(scatterOrReflect < targetMat.smoothness)
    {
        vec3 reflected = reflect(normalize(rayIn.direction), rec.normal);
        scattered.origin = rec.point;
        scattered.direction = reflected;
        attenuation = targetMat.colour;
    }
    else
    {
        vec3 scatterDirection = rec.normal + RandomUnitVector(seed);
        if(NearZero(scatterDirection))
            scatterDirection = rec.normal;

        scattered.origin = rec.point;
        scattered.direction = scatterDirection;
        attenuation = targetMat.colour;
    }

    return true;
}

bool MaterialEmission(Ray rayIn, RayHit rec, out vec3 emitted)
{
    Material targetMat = materials[rec.matIndex];
    emitted = targetMat.colour * targetMat.emission;
    return true;
}

float LinearToGamma(float linearComponent)
{
    if(linearComponent > 0)
		return sqrt(linearComponent);

    return 0;
}

vec3 GetEnvironmentColour(Ray ray)
{
    vec3 unitDir = normalize(ray.direction);
    vec3 sunDir  = normalize(PushConstants.sunDir);
    float sunDotUp = dot(-sunDir, vec3(0,1,0)); // how high the sun is (1=zenith, 0=horizon, <0=below horizon)

    // Base sky colours for different times
    vec3 dayZenith    = vec3(0.5, 0.7, 1.0);   // bright blue
    vec3 dayHorizon   = vec3(1.0, 1.0, 1.0);   // whiteish horizon
    vec3 sunriseColor = vec3(1.0, 0.4, 0.2);   // warm orange
    vec3 nightZenith  = vec3(0.0, 0.0, 0.0); // deep blue night
    vec3 nightHorizon = vec3(0.0, 0.0, 0.0);  // dark horizon glow

    // Vertical gradient factor (ray direction, not sun)
    float viewT = clamp(0.5 * (unitDir.y + 1.0), 0.0, 1.0);

    // ----- Choose base sky depending on sun height -----
    vec3 baseSky;
    if (sunDotUp > 0.1)
    {
        // Daytime
        baseSky = mix(dayHorizon, dayZenith, viewT);
    } 
    else if (sunDotUp > -0.1) 
    {
        // Sunrise/Sunset transition zone
        float blend = (sunDotUp + 0.1) / 0.2;
        vec3 daySky   = mix(dayHorizon, dayZenith, viewT);
        vec3 sunSky   = mix(sunriseColor, sunriseColor * 0.5, viewT);
        baseSky = mix(sunSky, daySky, blend);
    } 
    else
    {
        // Night
        baseSky = mix(nightHorizon, nightZenith, viewT);
    }

    // ----- Sun glow -----
    float cosTheta = dot(unitDir, -sunDir); // looking toward sun?
    cosTheta = clamp(cosTheta, 0.0, 1.0);

    float sunDisk = exp(-pow(acos(cosTheta) / radians(0.5), 2.0));
    vec3 sunGlow = PushConstants.sunColour * PushConstants.sunStrength * sunDisk;

    return baseSky + sunGlow;
}

vec3 DefocusDiskSample(uint seed)
{
	vec3 p = RandomInUnitDisk(seed);
	return PushConstants.cameraPosition + p.x * PushConstants.defocusU + p.y * PushConstants.defocusV;
}

Ray GetRay(ivec2 pixelCoord, uint seed)
{
    Ray ray;

    vec3 offset = SampleSquare(seed);
	vec3 pixel_sample = PushConstants.pixel00Location + ((pixelCoord.x + offset.x) * PushConstants.pixelDeltaU) + ((pixelCoord.y + offset.y) * PushConstants.pixelDeltaV);

	vec3 ray_origin = (PushConstants.defocusAngle <= 0) ? PushConstants.cameraPosition : DefocusDiskSample(seed);
	vec3 ray_direction = pixel_sample - ray_origin;

    ray.origin = ray_origin;
    ray.direction = normalize(ray_direction);

    return ray;
}

vec3 RayColour(Ray ray, inout RayHit rec, inout uint seed)
{
    vec3 result = vec3(0.0);
    vec3 throughput = vec3(1.0);

    for (int bounce = 0; bounce < PushConstants.maxBounces; bounce++)
    {
        Interval t; t.min = 0.001; t.max = 100000.0;
        float closestSoFar = t.max;
        bool hitObject = false;

        for (int i = 0; i < PushConstants.sphereCount; i++)
        {
            Interval newInterval; newInterval.min = t.min; newInterval.max = closestSoFar;
            if (IntersectSphere(ray, spheres[i], newInterval, rec))
            {
                closestSoFar = rec.t;
                hitObject = true;
            }
        }

        if (!hitObject)
        {
            vec3 bg = GetEnvironmentColour(ray);
            result += throughput * bg;
            break;
        }

        // Emission
        vec3 emitted;
        MaterialEmission(ray, rec, emitted);
        result += throughput * emitted;

        // If the material is emissive, stop bouncing
        Material recMat = materials[rec.matIndex];
        if (recMat.emission > 0.0)
        {
            break;
        }

        // Direct lighting (sun)
        float nDotL = max(dot(rec.normal, -PushConstants.sunDir), 0.0);
        if(nDotL > 0.0)
        {
            Ray shadowRay;
            shadowRay.origin = rec.point + rec.normal * 0.001;
            shadowRay.direction = -PushConstants.sunDir;

            bool occluded = AnyHit(shadowRay, 0.001, 1e20);
            if(!occluded)
            {
                vec3 sun = PushConstants.sunStrength * PushConstants.sunColour;
                const float INV_PI = 0.31830988618;
                vec3 direct = sun * (nDotL * INV_PI);
                result += throughput * recMat.colour * direct;
            }
        }

        // Scatter
        Ray scattered;
        vec3 attenuation;
        if (!MaterialScatter(ray, rec, attenuation, scattered, seed))
        {
            break;
        }

        throughput *= attenuation;
        ray = scattered;
    }

    return result;
}

void main() 
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    ivec2 size = imageSize(outputImage);

    if (texelCoord.x < size.x && texelCoord.y < size.y)
    {
        vec4 newColour = vec4(0,0,0,1);
        vec4 accumulatedColour = imageLoad(accumulationImage, texelCoord);

        uint baseSeed = uint(texelCoord.x + texelCoord.y * size.x) + uint(PushConstants.frame) * 7919u; // prime multiplier
        for (int i = 0; i < PushConstants.raysPerPixel; i++)
        {
            uint seed = baseSeed + uint(i) * 37u; // different for each sample
            Ray ray = GetRay(texelCoord, seed);
            RayHit rec;
            newColour.rgb += RayColour(ray, rec, seed);
        }
        newColour.rgb /= float(PushConstants.raysPerPixel);

        accumulatedColour.rgb += newColour.rgb;
        imageStore(accumulationImage, texelCoord, accumulatedColour);

        vec4 avgColour = accumulatedColour;
        avgColour.rgb /= float(PushConstants.frame + 1);

        accumulatedColour[0] = LinearToGamma(accumulatedColour[0]);
        accumulatedColour[1] = LinearToGamma(accumulatedColour[1]);
        accumulatedColour[2] = LinearToGamma(accumulatedColour[2]);

        imageStore(outputImage, texelCoord, avgColour);
    }   
}