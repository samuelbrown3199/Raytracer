#version 450

#extension GL_GOOGLE_include_directive : require

#include "Random.glsl"

layout (local_size_x = 32, local_size_y = 32) in;
layout(rgba32f, set = 0, binding = 0) uniform image2D outputImage;
layout(rgba32f, set = 0, binding = 1) uniform image2D accumulationImage;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct Material
{
    vec3 colour;
    float smoothness;
    float fuzziness;
    float emission;
    float refractionIndex;
    vec3 absorbtion;
};

struct RayHit
{
    vec3 point;
    vec3 normal;
    int matIndex;
    float t;
    bool frontFace;
    bool hitObject;
};

vec3 PointAtT(float t, Ray ray)
{
	return ray.origin + t * ray.direction;
}

struct Interval
{
    float min;
    float max;
};

bool IntervalSurrounds(Interval interval, float value)
{
    return value >= interval.min && value <= interval.max;
}

struct AABB
{
    vec3 boxMin;
    vec3 boxMax;
};

struct BVHNode
{
    AABB aabb;
    int leftChild;
    int rightChild;
    int triangleStartIndex;
    int triangleCount;
};

struct ParentBVHNode
{
    BVHNode node;
    int objectIndex;
};

struct Triangle
{
    vec3 v0;
    vec3 v1;
    vec3 v2;
    vec2 uv0;
    vec2 uv1;
    vec2 uv2;
    vec3 n0;
    vec3 n1;
    vec3 n2;
    vec3 triCentroid;
};

struct Object
{
	int triangleStartIndex;
	int triangleCount;
	int materialIndex;

	mat4 inverseTransform;
};

layout(std140, set=1, binding=0) readonly buffer ParentBVHNodeBuffer
{
    ParentBVHNode parentBVH[];
};

layout(std140, set=1, binding=1) readonly buffer BVHNodeBuffer
{
    BVHNode bvhNodes[];
};

layout(std140, set=1, binding=2) readonly buffer TriangleBuffer
{
	Triangle triangles[];
};

layout(std140, set=1, binding=3) readonly buffer ObjectBuffer
{
    Object objects[];
};

layout(set=1, binding=4) readonly buffer MaterialBuffer
{
    Material materials[];
};

layout(push_constant) uniform constants
{	
    vec3 pixel00Location;
    int raysPerPixel;

    vec3 pixelDeltaU;
    int maxBounces;

    vec3 pixelDeltaV;
    float defocusAngle;

    vec3 cameraPosition;
    int parentBVHCount;

    vec3 defocusU;
    int accumulateFrames;

    vec3 defocusV;
    int frame;

    vec3 sunDir;
    float sunStrength;

    vec3 sunColour;
    int renderMode;

    int triangleTestThreshold;
    int bvhNodeTestThreshold;
    float depthDebugScale;

} PushConstants;

bool IntersectAABB(Ray ray, AABB box, inout Interval t)
{
    // assume ray.direction is normalized (or call normalize outside)
    for (int a = 0; a < 3; ++a)
    {
        float originA = ray.origin[a];
        float dirA = ray.direction[a];
        float minA = box.boxMin[a];
        float maxA = box.boxMax[a];

        if (abs(dirA) < 1e-8) {
            // Ray is parallel to slab. If origin not within slab -> miss.
            if (originA < minA || originA > maxA)
                return false;
            // else parallel and inside slab -> no change to t
        } else {
            float invD = 1.0 / dirA;
            float t0 = (minA - originA) * invD;
            float t1 = (maxA - originA) * invD;
            if (invD < 0.0) {
                // swap
                float tmp = t0;
                t0 = t1;
                t1 = tmp;
            }
            t.min = max(t.min, t0);
            t.max = min(t.max, t1);
            if (t.max <= t.min) return false;
        }
    }
    return true;
}

bool IntersectTriangle(Ray ray, Triangle tri, Interval t, in out RayHit rec)
{
    vec3 edge1 = tri.v1 - tri.v0;
    vec3 edge2 = tri.v2 - tri.v0;
    vec3 h = cross(ray.direction, edge2);
    float a = dot(edge1, h);
    if (abs(a) < 1e-8)
        return false; // Ray is parallel to triangle

    float invDet = 1.0 / a;
    vec3 s = ray.origin - tri.v0;
    float u = invDet * dot(s, h);
    if (u < 0.0 || u > 1.0)
        return false;

    vec3 sCross = cross(s, edge1);
    float v = invDet * dot(ray.direction, sCross);
    if (v < 0.0 || u + v > 1.0)
        return false;

    float hitT = invDet * dot(edge2, sCross);
    if (!IntervalSurrounds(t, hitT))
        return false;

    if(hitT > 1e-8)
    {
        rec.t = hitT;
        rec.point = PointAtT(rec.t, ray);

         // --- Smooth normal interpolation ---
        float w = 1.0 - u - v;
        vec3 interpolatedNormal = normalize(tri.n0 * w + tri.n1 * u + tri.n2 * v);

        rec.frontFace = dot(ray.direction, interpolatedNormal) < 0.0;
        rec.normal = rec.frontFace ? interpolatedNormal : -interpolatedNormal;
        rec.hitObject = true;

        return true;
    }
    else
    {
        return false;
    }
}

float GetDistanceToAABB(vec3 point, AABB box)
{
    float sqDist = 0.0;
    for (int i = 0; i < 3; i++)
    {
        float v = point[i];
        if (v < box.boxMin[i]) sqDist += (box.boxMin[i] - v) * (box.boxMin[i] - v);
        if (v > box.boxMax[i]) sqDist += (v - box.boxMax[i]) * (v - box.boxMax[i]);
    }
    return sqrt(sqDist);
}

bool NearZero(vec3 v)
{
    const float s = 1e-8;
    return (abs(v.x) < s) && (abs(v.y) < s) && (abs(v.z) < s);
}

float Reflectance(float cosine, float refIdx)
{
    // Use Schlick's approximation for reflectance.
    float r0 = (1.0 - refIdx) / (1.0 + refIdx);
    r0 = r0 * r0;
    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);
}

bool DielectricScatter(Ray rayIn, RayHit rec, float refIdx, out vec3 attenuation, out Ray scattered, uint seed)
{
    Material targetMat = materials[rec.matIndex];
    attenuation = targetMat.colour * exp(-targetMat.absorbtion * rec.t);
    float etaiOverEtat = rec.frontFace ? (1.0 / refIdx) : refIdx;
    vec3 unitDirection = normalize(rayIn.direction);
    float cosTheta = min(dot(-unitDirection, rec.normal), 1.0);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    bool cannotRefract = etaiOverEtat * sinTheta > 1.0;
    vec3 direction;
    if (cannotRefract || Reflectance(cosTheta, refIdx) > RandomFloatInRange(0, 1, seed))
        direction = reflect(unitDirection, rec.normal);
    else
        direction = refract(unitDirection, rec.normal, etaiOverEtat);
    scattered.origin = rec.point;
    scattered.direction = normalize(direction);
    return true;
}


bool MaterialScatter(Ray rayIn, RayHit rec, out vec3 attenuation, out Ray scattered, uint seed)
{
    float scatterOrReflect = RandomFloatInRange(0, 1, seed);
    Material targetMat = materials[rec.matIndex];

    if(targetMat.refractionIndex > 0.0)
    {
        return DielectricScatter(rayIn, rec, targetMat.refractionIndex, attenuation, scattered, seed);
    }

    const float EPSILON = 1e-4;

    if(scatterOrReflect < targetMat.smoothness)
    {
        vec3 reflected = reflect(normalize(rayIn.direction), rec.normal);
        reflected += targetMat.fuzziness * RandomOnHemisphere(rec.normal, seed);
        scattered.origin = rec.point + reflected * EPSILON;
        scattered.direction = normalize(reflected);
        attenuation = targetMat.colour;
    }
    else
    {
        vec3 scatterDirection = rec.normal + RandomUnitVector(seed);
        if(NearZero(scatterDirection))
            scatterDirection = rec.normal;

        scattered.origin = rec.point + scatterDirection * EPSILON;
        scattered.direction = normalize(scatterDirection);
        attenuation = targetMat.colour;
    }

    return true;
}

bool MaterialEmission(Ray rayIn, RayHit rec, out vec3 emitted)
{
    Material targetMat = materials[rec.matIndex];
    emitted = targetMat.colour * targetMat.emission;
    return true;
}

float LinearToGamma(float linearComponent)
{
    if(linearComponent > 0)
		return sqrt(linearComponent);

    return 0;
}

bool HitChildNode(Ray r, int nodeIndex, Interval t)
{
    if(nodeIndex == -1)
        return false;

    BVHNode node = bvhNodes[nodeIndex];
    return IntersectAABB(r, node.aabb, t);
}

bool GetHit(Ray r_in, float tMin, float tMax, out RayHit rec, inout int triangleTests, inout int bvhNodeTests)
{
    Ray r;
    r.origin = r_in.origin;
    r.direction = normalize(r_in.direction);

    float closestSoFar = tMax;
    rec.t = tMax;
    rec.hitObject = false;

    for (int i = 0; i < PushConstants.parentBVHCount; i++)
    {
        ParentBVHNode targetBVH = parentBVH[i];
        Interval interval; interval.min = tMin; interval.max = closestSoFar;

        bvhNodeTests++;

        if (!IntersectAABB(r, targetBVH.node.aabb, interval))
            continue;

        Object targetObject = objects[targetBVH.objectIndex];
        int start = targetObject.triangleStartIndex;
        int end   = start + targetObject.triangleCount;

        // Transform ray into local space
        vec4 localOrigin    = targetObject.inverseTransform * vec4(r.origin, 1.0);
        vec4 localDirection = targetObject.inverseTransform * vec4(r.direction, 0.0);

        Ray localRay;
        localRay.origin    = localOrigin.xyz;
        localRay.direction = normalize(localDirection.xyz);

        mat4 objectTransform = inverse(targetObject.inverseTransform); // world transform
        mat3 normalMatrix    = mat3(transpose(targetObject.inverseTransform));

        if (targetBVH.node.leftChild == -1 && targetBVH.node.rightChild == -1)
        {
            for (int t = 0; t < targetBVH.node.triangleCount; t++)
            {
                triangleTests++;

                int triIndex = targetBVH.node.triangleStartIndex + t;
                Interval triInterval; 
                triInterval.min = tMin; 
                triInterval.max = closestSoFar;

                RayHit tempRec;
                if (IntersectTriangle(localRay, triangles[triIndex], triInterval, tempRec))
                {
                    vec3 worldPoint  = (objectTransform * vec4(tempRec.point, 1.0)).xyz;
                    vec3 worldNormal = normalize(normalMatrix * tempRec.normal);
                    float worldT = dot(worldPoint - r.origin, r.direction);

                    if (worldT > tMin && worldT < closestSoFar)
                    {
                        closestSoFar  = worldT;
                        rec.t         = worldT; 
                        rec.point     = worldPoint;
                        rec.normal    = worldNormal;
                        rec.matIndex  = targetObject.materialIndex;
                        rec.frontFace = dot(r.direction, worldNormal) < 0.0;
                        rec.hitObject = true;
                    }
                }
            }

            continue;
        }

        // Stack-based BVH traversal
        int stack[32];
        int stackPtr = 0;
        if (targetBVH.node.leftChild != -1) stack[stackPtr++] = targetBVH.node.leftChild;
        if (targetBVH.node.rightChild != -1) stack[stackPtr++] = targetBVH.node.rightChild;

        while (stackPtr > 0)
        {
            int nodeIdx = stack[--stackPtr];
            BVHNode node = bvhNodes[nodeIdx];

            Interval nodeInterval; nodeInterval.min = tMin; nodeInterval.max = 1e30;

            bvhNodeTests++;

            if (!IntersectAABB(localRay, node.aabb, nodeInterval))
                continue;

            // Leaf node: test triangles
            if (node.leftChild == -1 && node.rightChild == -1)
            {
                for (int t = 0; t < node.triangleCount; t++)
                {
                    triangleTests++;

                    int triIndex = node.triangleStartIndex + t;
                    Interval triInterval; 
                    triInterval.min = tMin; 
                    triInterval.max = closestSoFar;

                    RayHit tempRec;
                    if (IntersectTriangle(localRay, triangles[triIndex], triInterval, tempRec))
                    {
                        vec3 worldPoint  = (objectTransform * vec4(tempRec.point, 1.0)).xyz;
                        vec3 worldNormal = normalize(normalMatrix * tempRec.normal);
                        float worldT = dot(worldPoint - r.origin, r.direction);

                        if (worldT > tMin && worldT < closestSoFar)
                        {
                            closestSoFar  = worldT;
                            rec.t         = worldT; 
                            rec.point     = worldPoint;
                            rec.normal    = worldNormal;
                            rec.matIndex  = targetObject.materialIndex;
                            rec.frontFace = dot(r.direction, worldNormal) < 0.0;
                            rec.hitObject = true;
                        }
                    }
                }
            }
            else
            {
                //TODO prioritise child nodes based on distance to ray origin
                //Also skip any nodes that are further away than closest hit.
                /*float distanceToLeft = 1e30;
                float distanceToRight = 1e30;

                if (node.leftChild != -1)
                {
                    distanceToLeft = GetDistanceToAABB(r.origin, bvhNodes[node.leftChild].aabb);
                }
                if (node.rightChild != -1)
                {
                    distanceToRight = GetDistanceToAABB(r.origin, bvhNodes[node.rightChild].aabb);
                }

                if(distanceToLeft < distanceToRight)
                {
                    if (node.leftChild != -1)  stack[stackPtr++] = node.leftChild;
                    if (node.rightChild != -1) stack[stackPtr++] = node.rightChild;
                }
                else
                {
                    if (node.rightChild != -1) stack[stackPtr++] = node.rightChild;
                    if (node.leftChild != -1)  stack[stackPtr++] = node.leftChild;
                }*/

                if (node.leftChild != -1)  stack[stackPtr++] = node.leftChild;
                if (node.rightChild != -1) stack[stackPtr++] = node.rightChild;
            }
        }
    }

    return rec.hitObject;
}

vec3 ShadowTransmission(Ray r, float tMin, float tMax, inout int triangleTests, inout int bvhNodeTests)
{
    RayHit rec;
    vec3 transmission = vec3(1.0);

    // Trace the shadow ray for occluders
    int maxIterations = 4;
    while (GetHit(r, tMin, tMax, rec, triangleTests, bvhNodeTests))
    {
        maxIterations--;
        if(maxIterations == 0)
            break;

        Material mat = materials[rec.matIndex];

        // Handle transparent/refractive materials (Beer-Lambert law)
        if (mat.refractionIndex > 0.0)
        {
            float dist = rec.t;
            transmission *= exp(-mat.absorbtion * dist);
            // Move the ray origin past this object and keep searching
            r.origin = rec.point + rec.normal * 0.001;
            tMin = 0.001;
            continue;
        }

        // Opaque: fully block the shadow
        return vec3(0.0);
    }

    // No occluder found, return accumulated transmission
    return transmission;
}

vec3 GetEnvironmentColour(Ray ray)
{
    vec3 unitDir = normalize(ray.direction);
    vec3 sunDir  = normalize(PushConstants.sunDir);
    float sunDotUp = dot(-sunDir, vec3(0,1,0)); // how high the sun is (1=zenith, 0=horizon, <0=below horizon)

    // Base sky colours for different times
    vec3 dayZenith    = vec3(0.5, 0.7, 1.0);   // bright blue
    vec3 dayHorizon   = vec3(1.0, 1.0, 1.0);   // whiteish horizon
    vec3 sunriseColor = vec3(1.0, 0.4, 0.2);   // warm orange
    vec3 nightZenith  = vec3(0.0, 0.0, 0.0); // deep blue night
    vec3 nightHorizon = vec3(0.0, 0.0, 0.0);  // dark horizon glow

    // Vertical gradient factor (ray direction, not sun)
    float viewT = clamp(0.5 * (unitDir.y + 1.0), 0.0, 1.0);

    // ----- Choose base sky depending on sun height -----
    vec3 baseSky;
    if (sunDotUp > 0.1)
    {
        // Daytime
        baseSky = mix(dayHorizon, dayZenith, viewT);
    } 
    else if (sunDotUp > -0.1) 
    {
        // Sunrise/Sunset transition zone
        float blend = (sunDotUp + 0.1) / 0.2;
        vec3 daySky   = mix(dayHorizon, dayZenith, viewT);
        vec3 sunSky   = mix(sunriseColor, sunriseColor * 0.5, viewT);
        baseSky = mix(sunSky, daySky, blend);
    } 
    else
    {
        // Night
        baseSky = mix(nightHorizon, nightZenith, viewT);
    }

    // ----- Sun glow -----
    float cosTheta = dot(unitDir, -sunDir); // looking toward sun?
    cosTheta = clamp(cosTheta, 0.0, 1.0);

    float sunDisk = exp(-pow(acos(cosTheta) / radians(0.5), 2.0));
    vec3 sunGlow = PushConstants.sunColour * PushConstants.sunStrength * sunDisk;

    return baseSky + sunGlow;
}

vec3 DefocusDiskSample(uint seed)
{
	vec3 p = RandomInUnitDisk(seed);
	return PushConstants.cameraPosition + p.x * PushConstants.defocusU + p.y * PushConstants.defocusV;
}

Ray GetRay(ivec2 pixelCoord, uint seed)
{
    Ray ray;

    vec3 offset = SampleSquare(seed);
	vec3 pixel_sample = PushConstants.pixel00Location + ((pixelCoord.x + offset.x) * PushConstants.pixelDeltaU) + ((pixelCoord.y + offset.y) * PushConstants.pixelDeltaV);

	vec3 ray_origin = (PushConstants.defocusAngle <= 0) ? PushConstants.cameraPosition : DefocusDiskSample(seed);
	vec3 ray_direction = pixel_sample - ray_origin;

    ray.origin = ray_origin;
    ray.direction = normalize(ray_direction);

    return ray;
}

vec3 RayColour(Ray ray, inout RayHit rec, inout uint seed, inout int triangleTests, inout int bvhNodeTests)
{
    vec3 result = vec3(0.0);
    vec3 throughput = vec3(1.0);

    for (int bounce = 0; bounce < PushConstants.maxBounces+1; bounce++)
    {
        GetHit(ray, 0.001, 1e20, rec, triangleTests, bvhNodeTests);

        if (!rec.hitObject)
        {
            vec3 bg = GetEnvironmentColour(ray);
            result += throughput * bg;
            break;
        }

        if (!rec.frontFace)
        {
            break;
        }

        // Emission
        vec3 emitted;
        MaterialEmission(ray, rec, emitted);
        result += throughput * emitted;

        // If the material is emissive, stop bouncing
        Material recMat = materials[rec.matIndex];
        if (recMat.emission > 0.0)
        {
            break;
        }

        // Direct lighting (sun)
        float nDotL = max(dot(rec.normal, -PushConstants.sunDir), 0.0);
        if(nDotL > 0.0)
        {
            Ray shadowRay;
            shadowRay.origin = rec.point + rec.normal * 0.001;
            shadowRay.direction = -PushConstants.sunDir;

            vec3 shadowTrans = ShadowTransmission(shadowRay, 0.001, 1e20, triangleTests, bvhNodeTests);
            if (shadowTrans != vec3(0.0)) {
                vec3 sun = PushConstants.sunStrength * PushConstants.sunColour;
                const float INV_PI = 0.31830988618;
                vec3 direct = sun * (nDotL * INV_PI);

                // Only apply direct lighting to non-refractive (non-glass) materials
                if (recMat.refractionIndex == 0.0)
                {
                    result += throughput * recMat.colour * direct * shadowTrans;
                }
                else if (recMat.refractionIndex > 0.0)
                {
                     float fresnel = Reflectance(nDotL, recMat.refractionIndex);
                     result += throughput * fresnel * direct * shadowTrans;
                }
            }
        }

        // Scatter
        Ray scattered;
        vec3 attenuation;
        if (!MaterialScatter(ray, rec, attenuation, scattered, seed))
        {
            break;
        }

        throughput *= attenuation;
        ray = scattered;
    }

    return result;
}

void Pathtrace(ivec2 texelCoord, ivec2 size)
{
    vec4 newColour = vec4(0,0,0,1);
    vec4 accumulatedColour = imageLoad(accumulationImage, texelCoord);

    int triangleTests = 0;
    int bvhNodeTests = 0;

    for (int i = 0; i < PushConstants.raysPerPixel; i++)
    {
        uint seed = SeedFromCoords(texelCoord.x, texelCoord.y, PushConstants.frame, i);
        Ray ray = GetRay(texelCoord, seed);
        RayHit rec;
        newColour.rgb += RayColour(ray, rec, seed, triangleTests, bvhNodeTests);
    }

    if(PushConstants.renderMode == 0)
    {
        newColour.rgb /= float(PushConstants.raysPerPixel);

        accumulatedColour.rgb += newColour.rgb;
        imageStore(accumulationImage, texelCoord, accumulatedColour);

        vec4 avgColour = PushConstants.accumulateFrames == 1 ? accumulatedColour : newColour;
        avgColour.rgb /= PushConstants.accumulateFrames == 1 ? float(PushConstants.frame + 1) : 1;

        avgColour[0] = LinearToGamma(avgColour[0]);
        avgColour[1] = LinearToGamma(avgColour[1]);
        avgColour[2] = LinearToGamma(avgColour[2]);

        imageStore(outputImage, texelCoord, avgColour);
    }
    else if (PushConstants.renderMode == 3 || PushConstants.renderMode == 4)
    {
        const int thresholdTests = PushConstants.renderMode == 3 ? PushConstants.triangleTestThreshold : PushConstants.bvhNodeTestThreshold;
        int targetTestValue = PushConstants.renderMode == 3 ? triangleTests : bvhNodeTests;

        int greyScale = int(float(targetTestValue) / float(thresholdTests) * 255.0);
        greyScale = clamp(greyScale, 0, 255);
        newColour = vec4(float(greyScale) / 255.0, float(greyScale) / 255.0, float(greyScale) / 255.0, 1.0);

        if(triangleTests > thresholdTests)
            newColour = vec4(1,0,0,1);

        imageStore(outputImage, texelCoord, newColour);
    }
}

void RenderBoundingBoxes(ivec2 texelCoord, ivec2 size)
{
    vec4 outColour = vec4(0,0,0,1);
    Ray ray = GetRay(texelCoord, 123u); // seed not important
    RayHit rec;
    for (int i = 0; i < PushConstants.parentBVHCount; i++)
    {
        ParentBVHNode targetBVH = parentBVH[i];
        Interval interval; interval.min = 0.001; interval.max = 1e20;
        if (IntersectAABB(ray, targetBVH.node.aabb, interval))
        {
            outColour = vec4(1,0,0,1);
            break;
        }
    }
    imageStore(outputImage, texelCoord, outColour);
}

void RenderDepth(ivec2 texelCoord, ivec2 size)
{
    Ray ray = GetRay(texelCoord, 123u); // seed not important for depth
    RayHit rec;

    int triangleTests = 0;
    int bvhNodeTests = 0;

    if (GetHit(ray, 0.001, 1e20, rec, triangleTests, bvhNodeTests))
    {
        float depth = length(rec.point - PushConstants.cameraPosition);
        depth = clamp(depth / PushConstants.depthDebugScale, 0.0, 1.0); // normalize
        imageStore(outputImage, texelCoord, vec4(depth, depth, depth, 1.0));
    }
    else
    {
        imageStore(outputImage, texelCoord, vec4(0,0,0,1));
    }
}

void main() 
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    ivec2 size = imageSize(outputImage);

    if (texelCoord.x < size.x && texelCoord.y < size.y)
    {
        if(PushConstants.renderMode == 0 || PushConstants.renderMode == 3 || PushConstants.renderMode == 4)
            Pathtrace(texelCoord, size);
        else if(PushConstants.renderMode == 1)
            RenderBoundingBoxes(texelCoord, size);
        else if(PushConstants.renderMode == 2)
            RenderDepth(texelCoord, size);
    }   
}