#version 450

#extension GL_GOOGLE_include_directive : require

#include "Random.glsl"

layout (local_size_x = 32, local_size_y = 32) in;
layout(rgba16f, set = 0, binding = 0) uniform image2D image;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct Material
{
    vec3 colour;
    float smoothness;
};

struct RayHit
{
    vec3 point;
    vec3 normal;
    Material mat;
    float t;
    bool frontFace;
    bool hitObject;
};

vec3 PointAtT(float t, Ray ray)
{
	return ray.origin + t * ray.direction;
}

struct Interval
{
    float min;
    float max;
};

bool IntervalSurrounds(Interval interval, float value)
{
    return value >= interval.min && value <= interval.max;
}

struct Sphere
{
    vec3 center;
    float radius;
    vec3 colour;
};

layout(set=1, binding=0) readonly buffer SphereBuffer
{
	Sphere spheres[];
};

layout(push_constant) uniform constants
{	
    vec3 pixel00Location;
    int raysPerPixel;

    vec3 pixelDeltaU;
    int maxBounces;

    vec3 pixelDeltaV;
    float defocusAngle;

    vec3 cameraPosition;
    int sphereCount;

    vec3 defocusU;
    int renderMode;

    vec3 defocusV;
    int frame;

} PushConstants;

bool IntersectSphere(Ray ray, Sphere sphere, Interval t, out RayHit rec)
{
	vec3 oc = sphere.center - ray.origin;
	float a = length(ray.direction)*length(ray.direction);
	float h = dot(ray.direction, oc);
	float c = (length(oc)*length(oc)) - sphere.radius * sphere.radius;
	float discriminant = h * h - a * c;
	if (discriminant < 0)
		return false;

	float sqrtDiscriminant = sqrt(discriminant);
	float root = (h - sqrtDiscriminant) / a;
	if (!IntervalSurrounds(t, root))
	{
		root = (h + sqrtDiscriminant) / a;
		if (!IntervalSurrounds(t, root))
			return false;
	}

	rec.t = root;
	rec.point = PointAtT(rec.t, ray);
	vec3 outwardNormal = (rec.point - sphere.center) / sphere.radius;
    rec.normal = outwardNormal;
    rec.mat.colour = sphere.colour;

	return true;
}

bool NearZero(vec3 v)
{
    const float s = 1e-8;
    return (abs(v.x) < s) && (abs(v.y) < s) && (abs(v.z) < s);
}

bool MaterialScatter(Ray rayIn, RayHit rec, out vec3 attenuation, out Ray scattered, uint seed)
{
    float scatterOrReflect = RandomFloatInRange(0, 1, seed);
    if(scatterOrReflect < rec.mat.smoothness)
    {
        vec3 reflected = reflect(normalize(rayIn.direction), rec.normal);
        scattered.origin = rec.point;
        scattered.direction = reflected;
        attenuation = rec.mat.colour;
    }
    else
    {
        vec3 scatterDirection = rec.normal + RandomUnitVector(seed);
        if(NearZero(scatterDirection))
            scatterDirection = rec.normal;

        scattered.origin = rec.point;
        scattered.direction = scatterDirection;
        attenuation = rec.mat.colour;
    }

    return true;
}

float LinearToGamma(float linearComponent)
{
    if(linearComponent > 0)
		return sqrt(linearComponent);

    return 0;
}

vec3 GetEnvironmentColour(Ray ray)
{
    vec3 unitDirection = normalize(ray.direction);
    float t = 0.5 * (unitDirection.y + 1.0);
    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
}

vec3 DefocusDiskSample(uint seed)
{
	vec3 p = RandomInUnitDisk(seed);
	return PushConstants.cameraPosition + p.x * PushConstants.defocusU + p.y * PushConstants.defocusV;
}

Ray GetRay(ivec2 pixelCoord, uint seed)
{
    Ray ray;

    vec3 offset = SampleSquare(seed);
	vec3 pixel_sample = PushConstants.pixel00Location + ((pixelCoord.x + offset.x) * PushConstants.pixelDeltaU) + ((pixelCoord.y + offset.y) * PushConstants.pixelDeltaV);

	vec3 ray_origin = (PushConstants.defocusAngle <= 0) ? PushConstants.cameraPosition : DefocusDiskSample(seed);
	vec3 ray_direction = pixel_sample - ray_origin;

    ray.origin = ray_origin;
    ray.direction = normalize(ray_direction);

    return ray;
}

vec3 RayColour(Ray ray, inout RayHit rec, inout uint seed)
{
    vec3 result = vec3(0.0);
    vec3 throughput = vec3(1.0);

    for (int bounce = 0; bounce < PushConstants.maxBounces; bounce++)
    {
        Interval t; t.min = 0.001; t.max = 100000.0;
        float closestSoFar = t.max;
        bool hitObject = false;

        for (int i = 0; i < PushConstants.sphereCount; i++)
        {
            Interval newInterval; newInterval.min = t.min; newInterval.max = closestSoFar;
            if (IntersectSphere(ray, spheres[i], newInterval, rec))
            {
                closestSoFar = rec.t;
                hitObject = true;
            }
        }

        if (!hitObject)
        {
            vec3 bg = GetEnvironmentColour(ray);
            result += throughput * bg;
            break;
        }
        
        //TODO: Emission
        // vec3 emitted = rec.mat.emission; // example
        // result += throughput * emitted;

        // Scatter
        Ray scattered;
        vec3 attenuation;
        if (!MaterialScatter(ray, rec, attenuation, scattered, seed))
        {
            // absorbed: terminate
            break;
        }

        throughput *= attenuation;
        ray = scattered;
    }

    return result;
}

void main() 
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    ivec2 size = imageSize(image);

    if (texelCoord.x < size.x && texelCoord.y < size.y)
    {
        vec4 colour = vec4(0,0,0,1);

        uint seed = PushConstants.frame;
        RandomSeed(seed);
        seed = SeedFromCoords(texelCoord.x + localCoord.x, texelCoord.y +  localCoord.y);

        for (int i = 0; i < PushConstants.raysPerPixel; i++)
        {
            float junk = RandomSeed(seed);

            Ray ray = GetRay(texelCoord, seed);
            RayHit rec;

            colour.rgb += RayColour(ray, rec, seed);
        }
        colour.rgb /= float(PushConstants.raysPerPixel);

        colour[0] = LinearToGamma(colour[0]);
        colour[1] = LinearToGamma(colour[1]);
        colour[2] = LinearToGamma(colour[2]);

        imageStore(image, texelCoord, colour);
    }   
}